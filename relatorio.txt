Procure TODO antes de mandar!
(aqui e no código =P)

Nesse relatório, descrevemos a implementação de um jogo do estilo brickbreaker, realizada como exercício programa da disciplina "Computação Móvel", ministrada no primeiro semestre de 2014 no Instituto de Matemática e estatística da USP.


Motivação do trabalho

O trabalho consiste na implementação de um jogo no estilo brickbreaker na plataforma android. Esse modelo de jogo é bastante popular e tem diversas implementações disponíveis. 

O interesse maior no trabalho era de aprendizado, tanto de desenvolvimento de jogos em geral, como das peculiaridades que surgem quando se implementa esse jogo em um dispositivo móvel. 

Dispositivos móveis trazem muitas possibilidades para o desenvolvimento de jogos que não existem em consoles mais tradicionais: A interação com o usuário é normalmente feita via toque na tela (ao invés de teclado ou mouse); alguns dispositivos móveis oferece diversos sensores que podem ser explorados (como acelerômetro, magnetômetro e GPS); existe a possibilidade de usar a tela nas orientações retrato e paisagem (em oposição aos consoles tradicionais que costumam apenas oferecer a orientação "paisagem"); os jogos podem ser vistos de mais de ângulos distintos por diferentes jogadores (porque a tela é relativamente pequena e móvel).

Nosso jogo explora bastante duas dessas características: a interação via toque e a possibilidade de diferentes jogadores verem a tela de ângulos diferentes (essa segunda, no modo multiplayer).


TODO descrição breve do jogo

Jogabilidade:
TODO current
Em termos de jogabilidade
Idéias para jogabilidade:
     -> precisão versus survival
     -> paddle calibravel
     -> golf calibravel
     -> tempo calibrável
     -> Pacing (1P vs 2P)
     -> vidas
2P parece ter tido boa reação

Features implementadas:
Som
TExturas
Blocos móveis
2P


TODO deixar a bolinha mais legal no 1P

TODO Descricao (manual do usuário)




TODO Extrutura do código


Comentários gerais sobre o código:

OpenGL:

Nosso código é construido usando a implementação de OpenGL ES 1.0 para android.

Escolhemos trabalhar com o OpenGL ES 1.0 em vez do 2.0 por dois motivos, principalmente:

1)simplicidade do pipeline: como dispúnhamos de tempo bastante limitado, principalmente para programar pareadamente, seria muito bom que mantivéssemos a complexidade a um mínimo. Isso se mostrou uma decisão acertada.

2)suporte a API legada: nos dispositivos que testamos, um Jelly Bean (4.2, API 16) e um KitKat (4.4, API 19), não haveria diferença. Mas, dado que o código de exemplo da TFG, no qual nos baseamos, suportava até a API 8 sem maiores problemas, decidimos que seria interessante manter o suporte para APIs baixas. Isso se mostrou razoável ao rodar o projeto em um Gingerbread (2.3, API 8).

As texturas são desenhadas em três passos: primeiro é pintado o fundo da textura (RGBA 255, 255, 255, 0), depois a textura em si, em tom de cinza, e depois a cor de overlay, com alpha blending source, one minus alpha source.

Os arquivos de textura foram feitos no Inkscape e GIMP.

Foi necessário um tempo considerável para entender que deveria ser habilitado o modo GL_BLEND para que o alpha blending funcionasse, mesmo com a função gltexenv(GL_TEX_ENV_MODE) configurada corretamente, pois a documentação dava a entender que essa função poderia ser usada em vez do modo GL_BLEND, não em conjunto. 

Desde o início, pensamos que a cor dos objetos pudesse ser mudada dinamicamente com o uso de um overlay colorido, em vez de termos texturas pré-colorizadas, o que permite uma flexibilidade muito maior em futuras implementações, e troca um armazenamento menor por um gasto maior de processamento, o que consideramos ser razoável para um jogo desse porte.


Som

Dois dos sons foram criados no BFXR, um aplicativo em Adobe AIR que permite sintetizar uma gama de sons "retrô".

O som de aplausos foi retirado do Freesound.org

A música, do site de Kevin McLeod, www.incompetech.com

Todos os sons foram obtidos com licenças CC-BY

Os efeitos sonoros são executados com um SoundPool; a música, com um MediaPlayer. Ambos foram colocados na classe SoundManager.


A tela:

Dispositivos diferentes têm telas com proporções diferentes. Nosso jogo se adapta a essas proporções: O tamanho horizontal da tela é calculado na função OnSurfaceChanged, implementada no arquivo TouchSurfaceView. Essa informação é propagada por todo o código: World, Brick e Paddle precisam dela para se construir corretamente.

Fisica, gráficos e Game Loop:

O jogo é fortemente baseado no padrão GameLoop, como explicado em: http://gameprogrammingpatterns.com/game-loop.html

A cada renderização da tela de jogo, calculamos quanto tempo se passou (desde a última renderização) e fazemos a quantidade correspondente de passos da engine de física. Um passo do engine de fisica corresponde a uma quantidade fixa de tempo real (de alguns milissegundos). Isso permite que a execução da física seja consistente, mesmo quando temos devices com capacidades de processamento muito diferentes.

Infelizmente, a quantidade de tempo passado entre duas renderizações pode não ser multipla da quantidade de tempo em que ocorre um passo da física. Isso pode gerar artefatos visuais: a bolinha pode parecer se mover mais rapidamente numa mudança de frame, e mais lentamente na mudança de frame seguinte. Pudemos observar esse efeito quando testamos a aplicação em celulares mais antigos, mas ele não nos pareceu ser grande o bastante para comprometer a experiência do usuário.

Outro problema que teoricamente poderia surgir seria o tempo de execução de um passo da física demorar mais do que o tempo real a que ele corresponde. Nesse caso, o jogo ficaria completamente impossível de jogar. Felizmente, não observamos esse comportamento em nenhum dos celulares em que testamos o jogo.


Detecção de colisão e efeitos da colisão

A cada passo da engine de física, os objetos se movimentam de acordo com as suas velocidades atuais. Se dois deles ocuparem o mesmo espaço, o programa detecta uma colisão, e altera as velocidades apropriadamente. No caso do jogo de um jogador, a velocidade alterada é sempre a da bolinha. No caso de dois jogadores, os blocos móveis podem ter sua velocidade alterada também.

Uma preocupação importante é utilizar velocidades suficientemente pequenas na engine de física para garantir que todas as colisões sejam detectadas: velocidades muito grandes poderiam permitir, por exemplo, que a bolinha "ultrapassasse" um bloquinho em um unico passo, sem nunca compartilhar espaço com ele. As velocidades utilizadas na engine de física respeitam essa restrição e evitam essas "ultrapassagens". Note que isso não restringe as velocidades possíveis de gameplay: para tornar o jogo mais rápido, basta executar mais passos da física por segundo.

Após a colisão com um bloco, a bola sofre reflexão, utilizando o eixo da força normal e um eixo paralelo como sistema de coordenadas

TODO desenhos: bola na superficie, bola no corner

Poderia haver um artefato na reflexão: se uma bola colidir com dois bloquinhos ao mesmo tempo, aplicar duas reflexões seguidas poderia gerar um artefato, como na ilustração

TODO desenho agregação de normais

Para evitar isso, implementamos da BrickList o seguinte comportamento: Ao detectar duas ou mais colisões, ao invés de realizar duas reflexões, somamos as direções das forças normais para obter uma nova força normal e realizar a reflexão

Paddle

O jogador controla a um objeto que chamamos de Paddle. Com essa Paddle, ele impede que a bolinha caia e direciona a bolinha.

Experimentamos três versões da Paddle, buscando melhorar a jogabilidade do jogo.

A primeira versão era simplesmente um Brick que se move. A reflexão na superficie superior era sempre a mesma, independente da posição relativa entre a Paddle e a bola. A única maneira de o usuário direcionar a bola era com colisões nos vértices da Paddle. Essa versão não oferecia ao usuário controle suficiente, e o jogo acabava ficando muito enfadonho.

A segunda versão implementava alterava o comportamento da reflexão na superfície superior. Ao invés da normal ser a normal usual (i.e., uma normal vertical) utilizávamos uma normal dependente do ponto de colisão. Quanto mais a direita do centro da Paddle a bola batesse, mais inclinada a direita ficaria a normal.

TODO: desenho da reflexão bizarra 

Infelizmente, esse modelo ainda pareceu complicado demais para permitir uma boa jogabilidade: a posição ideal para o jogador colocar a paddle dependia de muitas variáveis: a posição da bolinha, a velocidade da bolinha e o alvo que ele pretendia acertar.

desenho: angulo de reflexão

A ultima implementação da Paddle ignora a física para melhorar a jogabilidade. Nessa implementação, a direção da bola após a colisão é determinada pelo ponto de contato entre a Paddle e a bola. Quanto mais a direita do centro da Paddle a bola bate, mais a direita ela sai.

Uma coisa interessante nas ultimas duas implementações é que elas são parametrizadas: podemos facilmente alterar o código para aumentar ou diminuir os desvios causados pela Paddle. Assim, pudemos experimentar um pouco com diferentes desvios, para otimizar a jogabilidade. Seria interessante fazer um ajuste mais fino desses parâmetros. 
 
desenho: nova velocidade
desenho: nova velocidade, outro parametro

Bugs da Paddle:
A Paddle sai um pouco da tela. O toque do usuário determina o destino do centro da Paddle, assim, um toque no canto da tela faz com que um pedaço da Paddle deixe de estar visível. Isso seria trivial de corrigir, mas chegamos à conclusão de que ajuda um pouco na jogabilidade. It's not a bug, It's a feature!

A Paddle se move até o destino indicado pelo jogador. Nesse movimento, a velocidade dela é maior do que a velocidade da bola. Assim, algumas colisões entre a Paddle em movimento e a bola podem gerar imagens em que a bolinha e a Paddle se intersectam. Experimentamos algumas soluções para esse problema, mas não achamos nenhuma satisfatória.

Melhorias possíveis

Listamos aqui algumas melhorias que poderiam ser feitas no jogo (e qual consideramos serem suas relevâncias)

Há uma série de pequenos feedbacks visuais e auditivos que, cremos, aumentariam relevantemente a imersão do jogador:
* Seria interessante fazer com que a bola, ao destruir vários Bricks em um pequeno intervalo de tempo, emitisse  sons ligeiramente diferentes para cada bloquinho, gerando uma noção de "continuidade do movimento"
* Seria interessante criar uma animação para a destruição dos blocos
* Seria interessante um feedback visual na paddle para marcar o impacto. Ela poderia, por exemplo, oscilar brevemente

TODO ver
Em termos de jogabilidade, seria interessante implementar vidas no jogo de um jogador. Isso aumentaria um pouco a dificuldade. Da maneira atual, o jogador tem infinitas chances de vencer uma fase.

Melhorias de desempenho:
 Na classe Brick, seria interessante compartilhar o buffer para desenhar cada Brick entre todos os objetos (dado que o desenho pode ser feito com translações). Não sabemos qual seria a relevância dessa otimização
Seria possível otimizar os testes de colisão: se dividirmos o espaço disponível em setores, isso poderia reduzir drasticamente o número de colisões que são verificadas a cada passo do engine de física. Pelos nossos testes, porém, o teste de colisão, ingênuo como está, não consome uma quantidade relevante de tempo. Cremos que essa otimização, apesar de natural, não seria muito útil.

Bugs:
O aplicativo continua rodando quando a status bar é invocada e cobre a tela. Isso ocorre apesar de nós implementarmos corretamente o método onPause. Curiosamente, esse mesmo bug pode ser visto em jogos comerciais


Aprendizado:

GameLoop
Colisão
OpenGL
Interação touch (muito fácil!)
Questoes interessantes, respostas dificeis de achar:
o que torna um jogo interessante ? quais sao as features a respeito das quais pensar ?
Funcionamento do openGl: documentação meio esparsa

Referências

http://gameprogrammingpatterns.com/game-loop.html
http://insanitydesign.com/wp/projects/nehe-android-ports/
http://www.opengl.org/archives/resources/faq/technical/transparency.htm
http://developer.android.com/training/multiscreen/screendensities.html
http://developer.android.com/guide/topics/manifest/activity-element.html#config
https://www.khronos.org/opengles/sdk/1.1/docs/man/
http://www.pacdv.com/sounds/mechanical_sounds.html
http://www.freesound.org/people/Aiwha/sounds/189186/
http://www.bfxr.net
