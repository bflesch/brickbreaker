Procure TODO antes de mandar!
(aqui e no código =P)

Nesse relatório, descrevemos a implementação de um jogo do estilo brickbreaker, realizada como exercício programa da disciplina "Computação Móvel", ministrada no primeiro semestre de 2014 no Instituto de Matemática e estatística da USP.


Motivação do trabalho

O trabalho consiste na implementação de um jogo no estilo brickbreaker na plataforma android. Esse modelo de jogo é bastante popular e tem diversas implementações disponíveis. 

O interesse maior no trabalho era de aprendizado, tanto de desenvolvimento de jogos em geral, como das peculiaridades que surgem quando se implementa esse jogo em um dispositivo móvel. 

Dispositivos móveis trazem muitas possibilidades para o desenvolvimento de jogos que não existem em consoles mais tradicionais: A interação com o usuário é normalmente feita via toque na tela (ao invés de teclado ou mouse); alguns dispositivos móveis oferece diversos sensores que podem ser explorados (como acelerômetro, magnetômetro e GPS); existe a possibilidade de usar a tela nas orientações retrato e paisagem (em oposição aos consoles tradicionais que costumam apenas oferecer a orientação "paisagem"); os jogos podem ser vistos de mais de ângulos distintos por diferentes jogadores (porque a tela é relativamente pequena e móvel).

Nosso jogo explora bastante duas dessas características: a interação via toque e a possibilidade de diferentes jogadores verem a tela de ângulos diferentes (essa segunda, no modo multiplayer).


TODO descrição breve do jogo

TODO deixar a bolinha mais legal no 1P

TODO Descricao (manual do usuário)




TODO Extrutura do código


Comentários gerais sobre o código:

OpenGL:

Nosso código é construido usando a implementação de OpenGL ES 1.0 para android.

Escolhemos trabalhar com o OpenGL ES 1.0  em vez do 2.0 por dois motivos, principalmente:

1)simplicidade do pipeline: como dispúnhamos de tempo bastante limitado, principalmente para programar pareadamente, seria muito bom que mantivéssemos a complexidade a um mínimo

2)suporte a API legada: nos dispositivos que testamos, um Jelly Bean (4.2, API 16) e um KitKat (4.4, API 19), não haveria diferença. Mas, dado que o código de exemplo da TFG, no qual nos baseamos, suportava até a API 8 sem maiores problemas, decidimos que seria interessante manter o suporte para APIs baixas. Isso se mostrou razoável ao rodar o projeto em um Gingerbread (2.3, API 8).

TODO breno explicar openGL mais ?

A tela:

Dispositivos diferentes têm telas com proporções diferentes. Nosso jogo se adapta a essas proporções: O tamanho horizontal da tela é calculado na função OnSurfaceChanged, implementada no arquivo TouchSurfaceView. Essa informação é propagada por todo o código: World, Brick e Paddle precisam dela para se construir corretamente.

Fisica, gráficos e Game Loop:

O jogo é fortemente baseado no padrão GameLoop, como explicado em: http://gameprogrammingpatterns.com/game-loop.html

A cada renderização da tela de jogo, calculamos quanto tempo se passou (desde a última renderização) e fazemos a quantidade correspondente de passos da engine de física. Um passo do engine de fisica corresponde a uma quantidade fixa de tempo real (de alguns milissegundos). Isso permite que a execução da física seja consistente, mesmo quando temos devices com capacidades de processamento muito diferentes.

Infelizmente, a quantidade de tempo passado entre duas renderizações pode não ser multipla da quantidade de tempo em que ocorre um passo da física. Isso pode gerar artefatos visuais: a bolinha pode parecer se mover mais rapidamente numa mudança de frame, e mais lentamente na mudança de frame seguinte. Pudemos observar esse efeito quando testamos a aplicação em celulares mais antigos, mas ele não nos pareceu ser grande o bastante para comprometer a experiência do usuário.

Outro problema que teoricamente poderia surgir seria o tempo de execução de um passo da física demorar mais do que o tempo real a que ele corresponde. Nesse caso, o jogo ficaria completamente impossível de jogar. Felizmente, não observamos esse comportamento em nenhum dos celulares em que testamos o jogo.


Detecção de colisão e efeitos da colisão

A cada passo da engine de física, os objetos se movimentam de acordo com as suas velocidades atuais. Se dois deles ocuparem o mesmo espaço, o programa detecta uma colisão, e altera as velocidades apropriadamente. No caso do jogo de um jogador, a velocidade alterada é sempre a da bolinha. No caso de dois jogadores, os blocos móveis podem ter sua velocidade alterada também.

Uma preocupação importante é utilizar velocidades suficientemente pequenas na engine de física para garantir que todas as colisões sejam detectadas: velocidades muito grandes poderiam permitir, por exemplo, que a bolinha "ultrapassasse" um bloquinho em um unico passo, sem nunca compartilhar espaço com ele. As velocidades utilizadas na engine de física respeitam essa restrição e evitam essas "ultrapassagens". Note que isso não restringe as velocidades possíveis de gameplay: para tornar o jogo mais rápido, basta executar mais passos da física por segundo.

Após a colisão com um bloco, a bola sofre reflexão, utilizando o eixo da força normal e um eixo paralelo como sistema de coordenadas

TODO desenhos: bola na superficie, bola no corner

Poderia haver um artefato na reflexão: se uma bola colidir com dois bloquinhos ao mesmo tempo, aplicar duas reflexões seguidas poderia gerar um artefato, como na ilustração

TODO desenho agregação de normais

Para evitar isso, implementamos da BrickList o seguinte comportamento: Ao detectar duas ou mais colisões, ao invés de realizar duas reflexões, somamos as direções das forças normais para obter uma nova força normal e realizar a reflexão

Paddle

O jogador controla a um objeto que chamamos de Paddle. Com essa Paddle, ele impede que a bolinha caia e direciona a bolinha.

Experimentamos três versões da Paddle, buscando melhorar a jogabilidade do jogo.

A primeira versão era simplesmente um Brick que se move. A reflexão na superficie superior era sempre a mesma, independente da posição relativa entre a Paddle e a bola. A única maneira de o usuário direcionar a bola era com colisões nos vértices da Paddle. Essa versão não oferecia ao usuário controle suficiente, e o jogo acabava ficando muito enfadonho.

A segunda versão implementava alterava o comportamento da reflexão na superfície superior. Ao invés da normal ser a normal usual (i.e., uma normal vertical) utilizávamos uma normal dependente do ponto de colisão. Quanto mais a direita do centro da Paddle a bola batesse, mais inclinada a direita ficaria a normal.

TODO: desenho da reflexão bizarra 

Infelizmente, esse modelo ainda pareceu complicado demais para permitir uma boa jogabilidade: a posição ideal para o jogador colocar a paddle dependia de muitas variáveis: a posição da bolinha, a velocidade da bolinha e o alvo que ele pretendia acertar.

desenho: angulo de reflexão

A ultima implementação da Paddle ignora a física para melhorar a jogabilidade. Nessa implementação, a direção da bola após a colisão é determinada pelo ponto de contato entre a Paddle e a bola. Quanto mais a direita do centro da Paddle a bola bate, mais a direita ela sai.

Uma coisa interessante nas ultimas duas implementações é que elas são parametrizadas: podemos facilmente alterar o código para aumentar ou diminuir os desvios causados pela Paddle. Assim, pudemos experimentar um pouco com diferentes desvios, para otimizar a jogabilidade. Seria interessante fazer um ajuste mais fino desses parâmetros. 
 
desenho: nova velocidade
desenho: nova velocidade, outro parametro

Bugs da Paddle:
A Paddle sai um pouco da tela. O toque do usuário determina o destino do centro da Paddle, assim, um toque no canto da tela faz com que um pedaço da Paddle deixe de estar visível. Isso seria trivial de corrigir, mas chegamos à conclusão de que ajuda um pouco na jogabilidade. It's not a bug, It's a feature!

A Paddle se move até o destino indicado pelo jogador. Nesse movimento, a velocidade dela é maior do que a velocidade da bola. Assim, algumas colisões entre a Paddle em movimento e a bola podem gerar imagens em que a bolinha e a Paddle se intersectam. Experimentamos algumas soluções para esse problema, mas não achamos nenhuma satisfatória.

Melhorias possíveis

Listamos aqui algumas melhorias que poderiam ser feitas no jogo (e qual consideramos serem suas relevâncias)

Ideias para "juiciness"
sons diferentes piu piuuu poiull
impacto: bloco some animadamente
impacto: bola "vibra"
impacto: paddle desce
outra musica quando acontece a vitória
you win, you lose
trail
paddle nao ser invadida

Idéias para jogabilidade:
     -> precisão versus survival
     -> paddle calibravel
     -> golf calibravel
     -> tempo calibrável
     -> Pacing (1P vs 2P)
     -> vidas

Ideias para desempenho
 OpenGl: compartilhar o buffer dos bloquinhos
 Colisão: teste de colisao podia falhar mais rápido
          setorizar o espaço
          Profilling rudimentar indicou que isso não é um problema
 testes em celulares diferentes 

Testes com usuários
(o jogo de 2 players foi bem recebido, pelo menos num primeiro momento)
Testes com outros celulares (roda, mas graficos meio meia boca. Seria legal fazer mais)

Bug do android ? (temple run, smash e nóis)

Aprendizado:

GameLoop
Colisão
OpenGL
Interação touch (muito fácil!)
Questoes interessantes, respostas dificeis de achar:
o que torna um jogo interessante ? quais sao as features a respeito das quais pensar ?
Funcionamento do openGl: documentação meio esparsa

Referências

http://gameprogrammingpatterns.com/game-loop.html
http://insanitydesign.com/wp/projects/nehe-android-ports/
http://www.opengl.org/archives/resources/faq/technical/transparency.htm
http://developer.android.com/training/multiscreen/screendensities.html
http://developer.android.com/guide/topics/manifest/activity-element.html#config
https://www.khronos.org/opengles/sdk/1.1/docs/man/
http://www.pacdv.com/sounds/mechanical_sounds.html

